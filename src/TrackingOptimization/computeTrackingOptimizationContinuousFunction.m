% This function is part of the NMSM Pipeline, see file for full license.
%
% () -> ()
% 

% ----------------------------------------------------------------------- %
% The NMSM Pipeline is a toolkit for model personalization and treatment  %
% optimization of neuromusculoskeletal models through OpenSim. See        %
% nmsm.rice.edu and the NOTICE file for more information. The             %
% NMSM Pipeline is developed at Rice University and supported by the US   %
% National Institutes of Health (R01 EB030520).                           %
%                                                                         %
% Copyright (c) 2021 Rice University and the Authors                      %
% Author(s): Marleny Vega                                                 %
%                                                                         %
% Licensed under the Apache License, Version 2.0 (the "License");         %
% you may not use this file except in compliance with the License.        %
% You may obtain a copy of the License at                                 %
% http://www.apache.org/licenses/LICENSE-2.0.                             %
%                                                                         %
% Unless required by applicable law or agreed to in writing, software     %
% distributed under the License is distributed on an "AS IS" BASIS,       %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or         %
% implied. See the License for the specific language governing            %
% permissions and limitations under the License.                          %
% ----------------------------------------------------------------------- %

function computeTrackingOptimizationContinuousFunction(inputs, params)

load('continuousFunctionData.mat')
load('inputData.mat')
pointKinematics('optModel_GPOPS.osim');
inverseDynamics('optModel_GPOPS.osim');

persistent experimentalJointAngles experimentalJointMoments ...
    experimentalMuscleActivations experimentalRightGroundReactionForces ...
    experimentalLeftGroundReactionForces

values = getTrackingOptimizationValueStruct(inputs, params);

assignPersistentVariable(params, values.time);

[springPositions, springVelocities] = pointKinematics(values.time, ...
    values.statePositions, values.stateVelocities, ...
    params.springPointsOnBody', params.springBody, params.coordinateNames);

bodyLocations = getBodyLocations(values.time, values.statePositions, ...
    values.stateVelocities, params);

groundReactions = calcGroundReactions(springPositions, springVelocities, ...
    params, bodyLocations);
phaseout.groundReactions = tranferGroundReactionMoments(bodyLocations, ...
    groundReactions);

muscleActivations = calcMuscleActivationFromSynergies(values, params);

[jointAngles, jointVelocities] = getMuscleActuatedDOFs(values, params);

%% work on adding velocity to surrogate model
% [params.muscleTendonLengths, params.muscleTendonVelocities, ...
%     params.momentArms] = calcSurrogateModel(polynomialExpressions, ...
%     coefficients, jointAngles, jointVelocities);

[normalizedFiberLength, normalizedFiberVelocity] = ...
    calcNormalizedMuscleFiberLengthsAndVelocities(params, ...
    ones(1, params.numMuscles), ones(1, params.numMuscles));

params.momentArms = reshape(cat(2, params.momentArms{:}), 51, 31, 148);
permute(params.momentArms,[1 4 3 2]);
phaseout(1).muscleJointMoments = calcMuscleJointMoments( ...
    params, muscleActivations, normalizedFiberLength, ...
    normalizedFiberVelocity);

appliedLoads = [zeros(length(values.time), params.numActuators) ...
    phaseout.groundReactions.rightHeelForce phaseout.groundReactions.rightHeelMoment ...
    phaseout.groundReactions.leftHeelForce phaseout.groundReactions.leftHeelMoment ...
    phaseout.groundReactions.rightToeForce phaseout.groundReactions.rightToeMoment ...
    phaseout.groundReactions.leftToeForce phaseout.groundReactions.leftToeMoment ...
    ];

phaseout.inverseDynamicMoments = inverseDynamics(values.time, ...
    values.statePositions, values.stateVelocities, ...
    values.stateAccelerations, params.coordinateNames, appliedLoads);

phaseout(1).dynamics = (params.maxTime - params.minTime) * ...
    ([values.stateVelocities values.stateAccelerations ...
    values.controlJerks]) ./ (onescol * (params.maxState - params.minState));

%% create a function that merges ground reaction forces

jointAngleErrors = experimentalJointAngles - values.statePositions;
muscleActivationErrors = experimentalMuscleActivations - muscleActivations;
groundReactionErrors = experimentalGroundReactionForces - phaseout.groundReactions;
jointMomentErrors = experimentalJointMoments - phaseout.inverseDynamicMoments;

%% create getAcutatorLoads function
phaseout(1).path = ([ ...
    getAcutatorLoads(phaseout.inverseDynamicMoments, params, 'residuals')  ...
    getAcutatorLoads(phaseout.inverseDynamicMoments, params, 'muscleActuated') - phaseout(1).muscleJointMoments ...
    jointAngleErrors ...
    groundReactionErrors ...
     ] - ...
    ones(length(values.time), 1) * (params.pathmax + params.pathmin) / 2) ...
    ./ (ones(length(values.time), 1) * (params.pathmax - params.pathmin));

path = [getAcutatorLoads(inverseDynamicMoments, params, 'residuals')  ...
    getAcutatorLoads(inverseDynamicMoments, params, 'muscleActuated') - muscleJointMoments ...
    jointAngleErrors ...
    groundReactionErrors];

phaseout(1).path = scaleToBounds(path, params.pathmax, params.pathmin);

integrand = [jointAngleErrors ...
    groundReactionErrors ...
    jointMomentErrors ...
    muscleActivationErrors ...
    values.controlJerks] .^ 2;

phaseout.integrand = params.time(end) / values.time(end) * (integrand) ./ ...
    (params.maxIntegral - params.minIntegral);
end
function values = getTrackingOptimizationValueStruct(input, params)

values.time = scaleToOriginal(input.time, params.maxTime, ...
    params.minTime);
values.synergyWeights = scaleToOriginal(input.parameter(1,:), ...
    params.maxParameter, params.minParameter);
values.synergyWeights = reshape(values.synergyWeights, ...
    params.numRightSynergies + params.numLeftSynergies, []);
state = scaleToOriginal(input.state, ones(length(values.time), 1) .* ...
    params.maxState, ones(length(values.time), 1) .* params.minState);
control = scaleToOriginal(input.control, ones(length(values.time), 1) .* ...
    params.maxControl, ones(length(values.time), 1) .* params.minControl);
values.statePositions = getCorrectStates(state, 1, params.numCoordinates);
values.stateVelocities = getCorrectStates(state, 2, params.numCoordinates);
values.stateAccelerations = getCorrectStates(state, 3, params.numCoordinates);
values.controlJerks = control(:, 1 : params.numCoordinates);
values.controlNeuralCommandsRight = control(:, params.numCoordinates + 1 : ...
    params.numCoordinates + params.numRightSynergies);
values.controlNeuralCommandsLeft = control(:, params.numCoordinates + ...
    params.numRightSynergies + 1 : end);
end
function assignPersistentVariable(params, time)

if ~exist('experimentalJointAngles', 'var') || ...
        size(experimentalJointAngles, 1) ~= length(time)
assignin('caller', 'experimentalJointAngles', ...
    fnval(params.splineJointAngles, time)');
assignin('caller', 'experimentalJointMoments', ...
    fnval(params.splineJointMoments, time)');
assignin('caller', 'experimentalMuscleActivations', ...
    fnval(params.splineMuscleActivations, time)');
assignin('caller', 'experimentalRightGroundReactionForces', ...
    fnval(params.splineRightGroundReactionForces, time)');
assignin('caller', 'experimentalLeftGroundReactionForces', ...
    fnval(params.splineLeftGroundReactionForces, time)');
end
end
function output = getCorrectStates(state, index, numCoordinates)

startIndex = (numCoordinates * (index - 1)) + 1;
endIndex = numCoordinates * index;
output = state(:, startIndex:endIndex);
end
function value = scaleToOriginal(value, maximum, minimum)

value = value .* (maximum - minimum) + (maximum + minimum) / 2;
end
function value = scaleToBounds(value, maximum, minimum)

value = (value - (maximum + minimum) / 2) ./ (maximum - minimum);
end
function bodyLocations = getBodyLocations(time, statePositions, ...
    stateVelocities, params)

bodyLocations.rightMidfootSuperior = pointKinematics(time, statePositions, ...
    stateVelocities, params.rightMidfootSuperiorPointOnBody', ...
    params.rightMidfootSuperiorBody, params.coordinateNames);
bodyLocations.rightMidfootSuperior(:, 2) = 0;
bodyLocations.leftMidfootSuperior = pointKinematics(time, statePositions, ...
    stateVelocities, params.leftMidfootSuperiorPointOnBody', ...
    params.leftMidfootSuperiorBody, params.coordinateNames);
bodyLocations.leftMidfootSuperior(:, 2) = 0;

bodyLocations.rightHeel = pointKinematics(time, statePositions, ...
    stateVelocities, params.rightHeelPointOnBody', ...
    params.rightHeelBody, params.coordinateNames);
bodyLocations.leftHeel = pointKinematics(time, statePositions, ...
    stateVelocities, params.leftHeelPointOnBody', ...
    params.leftHeelBody, params.coordinateNames);

bodyLocations.rightToe = pointKinematics(time, statePositions, ...
    stateVelocities, params.rightToePointOnBody', ...
    params.rightToeBody, params.coordinateNames);
bodyLocations.leftToe = pointKinematics(time, statePositions, ...
    stateVelocities, params.leftToePointOnBody', ...
    params.leftToeBody, params.coordinateNames);
end
function groundReactions = tranferGroundReactionMoments(bodyLocations, ...
    groundReactions)

groundReactions.rightHeelMoment = transferMoments(...
    bodyLocations.rightMidfootSuperior, bodyLocations.rightHeel, ...
    groundReactions.rightHeelMoment, groundReactions.rightHeelForce);
groundReactions.leftHeelMoment = transferMoments( ...
    bodyLocations.leftMidfootSuperior, bodyLocations.leftHeel, ...
    groundReactions.leftHeelMoment, groundReactions.leftHeelForce);
groundReactions.rightToeMoment = transferMoments( ...
    bodyLocations.rightMidfootSuperior, bodyLocations.rightToe, ...
    groundReactions.rightToeMoment, groundReactions.rightToeForce);
groundReactions.leftToeMoment = transferMoments( ...
    bodyLocations.leftMidfootSuperior, bodyLocations.leftToe, ...
    groundReactions.leftToeMoment, groundReactions.leftToeForce);
end
function moment = transferMoments(newPosition, oldPosition, moment, force)

moment = cross(newPosition - oldPosition, force, 2) + moment;
end
function muscleActivations = calcMuscleActivationFromSynergies(values, params)

rightMuscleActivations = values.controlNeuralCommandsRight * values.synergyWeights(1 : params.numRightSynergies, :);
leftMuscleActivations = values.controlNeuralCommandsLeft * values.synergyWeights(params.numRightSynergies + 1 : end, :);
muscleActivations = [rightMuscleActivations leftMuscleActivations];
end
function [jointAngles, jointVelocities] = getMuscleActuatedDOFs( ...
    values, params)

for i = 1:params.numMuscles
    index = 1;
    for j = 1:size(params.dofsActuated, 1)
        if params.dofsActuated(j, i) > params.epsilon
            jointAngles{i}(:, index) = values.statePositions(:, j);
            jointVelocities{i}(:, index) = values.stateVelocities(:, j);
            index = index + 1;
        end
    end
end
end
function [muscleTendonLengths, muscleTendonVelocities, momentArms] = ...
    calcSurrogateModel(polynomialExpressions, coefficients, jointAngles, ...
    jointVelocities)

for i = 1 : size(jointAngles, 2)
    % Initialize symbolic thetas
    theta = sym('theta', [1 size(jointAngles{i}, 2)]);
    % Get A matrix
    matrix = getDataMatrix(polynomialExpressions.muscleTendonLengths{i}, ...
        polynomialExpressions.muscleTendonVelocities{i}, ...
        polynomialExpressions.momentArms{i}, jointAngles{i}, ...
        jointVelocities{i}, theta);
    % Caculate new muscle tendon lengths and moment arms
    vector = matrix * coefficients{i};
    muscleTendonLengths(:,i) = vector(1 : size(jointAngles{i}, 1));
    muscleTendonVelocities(:,i) = vector(size(jointAngles{i}, 1) + 1 : ...
        size(jointAngles{i}, 1) * 2);
    for j = 1 : size(jointAngles{i}, 2)
        momentArms{i}(:, j) = vector(size(jointAngles{i}, 1) * (j + 1) + ...
            1 : size(jointAngles{i}, 1) * (j + 2));
    end
end
end