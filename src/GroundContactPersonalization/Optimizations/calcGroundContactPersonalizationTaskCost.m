% This function is part of the NMSM Pipeline, see file for full license.
%
% 
%
% (struct, Array of string, struct, struct, double) -> (Array of double)
% Calculate cost for a Ground Contact Personalization task. 

% ----------------------------------------------------------------------- %
% The NMSM Pipeline is a toolkit for model personalization and treatment  %
% optimization of neuromusculoskeletal models through OpenSim. See        %
% nmsm.rice.edu and the NOTICE file for more information. The             %
% NMSM Pipeline is developed at Rice University and supported by the US   %
% National Institutes of Health (R01 EB030520).                           %
%                                                                         %
% Copyright (c) 2021 Rice University and the Authors                      %
% Author(s): Spencer Williams, Claire V. Hammond                          %
%                                                                         %
% Licensed under the Apache License, Version 2.0 (the "License");         %
% you may not use this file except in compliance with the License.        %
% You may obtain a copy of the License at                                 %
% http://www.apache.org/licenses/LICENSE-2.0.                             %
%                                                                         %
% Unless required by applicable law or agreed to in writing, software     %
% distributed under the License is distributed on an "AS IS" BASIS,       %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or         %
% implied. See the License for the specific language governing            %
% permissions and limitations under the License.                          %
% ----------------------------------------------------------------------- %

function cost = calcGroundContactPersonalizationTaskCost( ...
    values, fieldNameOrder, inputs, params, task)
% OpenSim models are non-serializable objects, so they cannot normally be
% passed to a parallel pool. Using a persistent variable, the models are
% opened once per parallel worker and repeatedly accessed. 
persistent models;
for foot = 1:length(inputs.surfaces)
    if ~isfield(models, "model_" + foot)
        models.("model_" + foot) = Model(inputs.surfaces{foot}.model);
    end
end
valuesStruct = unpackValues(values, inputs, fieldNameOrder);
% If a design variable is not included, its static value from inputs is
% added to valuesStruct so it can be used to calculate cost if needed. 
if ~params.tasks{task}.designVariables(1)
        valuesStruct.springConstants = inputs.springConstants;
end
if ~params.tasks{task}.designVariables(2)
        valuesStruct.dampingFactor = inputs.dampingFactor;
end
if ~params.tasks{task}.designVariables(3)
        valuesStruct.dynamicFrictionCoefficient = ...
            inputs.dynamicFrictionCoefficient;
end
if ~params.tasks{task}.designVariables(4)
        valuesStruct.viscousFrictionCoefficient = ...
            inputs.viscousFrictionCoefficient;
end
if ~params.tasks{task}.designVariables(5)
        valuesStruct.restingSpringLength = ...
            inputs.restingSpringLength;
end
if ~params.tasks{task}.designVariables(6)
    for foot = 1:length(inputs.surfaces)
        field = "bSplineCoefficients" + foot;
        valuesStruct.(field) = inputs.surfaces{foot}.bSplineCoefficients;
    end
end
cost = [];
for foot = 1:length(inputs.surfaces)
    field = "bSplineCoefficients" + foot;
    valuesBSplineCoefficients = ...
        reshape(valuesStruct.(field), [], 7);
    [modeledJointPositions, modeledJointVelocities] = ...
        calcGCPJointKinematics(inputs.surfaces{foot} ...
        .experimentalJointPositions, inputs.surfaces{foot} ...
        .jointKinematicsBSplines, valuesBSplineCoefficients);
    modeledValues = calcGCPModeledValues(inputs, valuesStruct, ...
        modeledJointPositions, modeledJointVelocities, params, task, ...
        foot, models);
    modeledValues.jointPositions = modeledJointPositions;
    modeledValues.jointVelocities = modeledJointVelocities;

    cost = [cost calcCost(inputs, params, modeledValues, valuesStruct, ...
        task, foot)];
end
end

% Reformats the values array of design variables to a simpler struct. 
function valuesStruct = unpackValues(values, inputs, fieldNameOrder)
valuesStruct = struct();
start = 1;
for i=1:length(fieldNameOrder)
    % Kinematics are specific to each foot, but other design variables are
    % shared. 
    if contains(fieldNameOrder(i), "bSplineCoefficients")
        foot = convertStringsToChars(fieldNameOrder(i));
        foot = str2double(foot(end));
        valuesStruct.(fieldNameOrder(i)) = values(start:start + ...
            numel(inputs.surfaces{foot}.bSplineCoefficients) - 1);
        start = start + numel(inputs.surfaces{foot}.bSplineCoefficients);
    else
        valuesStruct.(fieldNameOrder(i)) = values(start:start + ...
            numel(inputs.(fieldNameOrder(i))) - 1);
        if fieldNameOrder(i) == "springConstants"
            valuesStruct.(fieldNameOrder(i)) = ...
                1000 * valuesStruct.(fieldNameOrder(i));
        end
        start = start + numel(inputs.(fieldNameOrder(i)));
    end
end
end

% Calculates the overall cost using allowable errors and all included cost
% terms. 
function cost = calcCost(inputs, params, modeledValues, valuesStruct, ...
    task, foot)
cost = [];
if (params.tasks{task}.costTerms.markerPositionError.isEnabled || ...
        params.tasks{task}.costTerms.markerSlopeError.isEnabled)
    [footMarkerPositionError, footMarkerSlopeError] = ...
        calcFootMarkerPositionAndSlopeError(inputs.surfaces{foot}, ...
        modeledValues);
end
if (params.tasks{task}.costTerms.markerPositionError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.markerPositionError.maxAllowableError;
    cost = [cost sqrt(1 / length(footMarkerPositionError)) * ...
        (1 / maxAllowableError * footMarkerPositionError)];
end
if (params.tasks{task}.costTerms.markerSlopeError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.markerSlopeError.maxAllowableError;
    cost = [cost sqrt(1 / length(footMarkerSlopeError)) * ...
        (1 / maxAllowableError * footMarkerSlopeError)];
end
if (params.tasks{task}.costTerms.rotationError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.rotationError.maxAllowableError;
    cost = [cost sqrt(1 / (4 * size(modeledValues.jointPositions, 2))) ...
        * ((1 / maxAllowableError) * ...
        reshape(rad2deg(modeledValues.jointPositions(1:4, :)) - ...
        rad2deg(inputs.surfaces{foot}.experimentalJointPositions(1:4, :)), ...
        1, []))];
end
if (params.tasks{task}.costTerms.translationError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.translationError.maxAllowableError;
    cost = [cost sqrt(1 / (3 * size(modeledValues.jointPositions, 2))) ...
        * ((1 / maxAllowableError) * ...
        reshape(modeledValues.jointPositions(5:7, :) - ...
        inputs.surfaces{foot}.experimentalJointPositions(5:7, :), 1, []))];
end
if (params.tasks{task}.costTerms.coordinateCoefficientError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.coordinateCoefficientError ...
        .maxAllowableError;
    cost = [cost sqrt(1 / (inputs.surfaces{foot}.splineNodes * 7)) * (1 / ...
        maxAllowableError * calcKinematicsBSplineCoefficientError(...
        valuesStruct.bSplineCoefficients))];
end
if (params.tasks{task}.costTerms.verticalGrfError.isEnabled || ...
        params.tasks{task}.costTerms.verticalGrfSlopeError.isEnabled || ...
        params.tasks{task}.costTerms.horizontalGrfError.isEnabled || ...
        params.tasks{task}.costTerms.horizontalGrfSlopeError.isEnabled || ...
        params.tasks{task}.costTerms.groundReactionMomentError.isEnabled || ...
        params.tasks{task}.costTerms.groundReactionMomentSlopeError ...
        .isEnabled)
    if ~isfield(modeledValues, 'anteriorGrf')
        modeledValues.anteriorGrf = zeros(size(modeledValues.verticalGrf));
        modeledValues.lateralGrf = zeros(size(modeledValues.verticalGrf));
    end
    [groundReactionForceValueErrors, groundReactionForceSlopeErrors] = ...
        calcGroundReactionForceAndSlopeError(inputs.surfaces{foot}, ...
        modeledValues);
end
if (params.tasks{task}.costTerms.verticalGrfError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.verticalGrfError.maxAllowableError;
    cost = [cost sqrt(1 / size(groundReactionForceValueErrors, 2)) ...
        * (1 / maxAllowableError) * groundReactionForceValueErrors(2, :)];
end
if (params.tasks{task}.costTerms.verticalGrfSlopeError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.verticalGrfSlopeError ...
        .maxAllowableError;
    cost = [cost sqrt(1 / size(groundReactionForceSlopeErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionForceSlopeErrors(2, :)];
end
if (params.tasks{task}.costTerms.horizontalGrfError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.horizontalGrfError.maxAllowableError;
    cost = [cost sqrt(1 / size(groundReactionForceValueErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionForceValueErrors(1, :)];
    cost = [cost sqrt(1 / size(groundReactionForceValueErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionForceValueErrors(3, :)];
end
if (params.tasks{task}.costTerms.horizontalGrfSlopeError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.horizontalGrfSlopeError ...
        .maxAllowableError;
    cost = [cost sqrt(1 / size(groundReactionForceSlopeErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionForceSlopeErrors(1, :)];
    cost = [cost sqrt(1 / size(groundReactionForceSlopeErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionForceSlopeErrors(3, :)];
end
if (params.tasks{task}.costTerms.groundReactionMomentError.isEnabled || ...
        params.tasks{task}.costTerms.groundReactionMomentSlopeError ...
        .isEnabled)
    [groundReactionMomentErrors, groundReactionMomentSlopeErrors] = ...
        calcGroundReactionMomentAndSlopeError(inputs.surfaces{foot}, ...
        modeledValues); 
end
if (params.tasks{task}.costTerms.groundReactionMomentError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.groundReactionMomentError ...
        .maxAllowableError;
    cost = [cost sqrt(1 / size(groundReactionMomentErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionMomentErrors(1, :)];
    cost = [cost sqrt(1 / size(groundReactionMomentErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionMomentErrors(2, :)];
    cost = [cost sqrt(1 / size(groundReactionMomentErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionMomentErrors(3, :)];
end
if (params.tasks{task}.costTerms.groundReactionMomentSlopeError.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.groundReactionMomentSlopeError ...
        .maxAllowableError;
    cost = [cost sqrt(1 / size(groundReactionMomentSlopeErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionMomentSlopeErrors(1, :)];
    cost = [cost sqrt(1 / size(groundReactionMomentSlopeErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionMomentSlopeErrors(2, :)];
    cost = [cost sqrt(1 / size(groundReactionMomentSlopeErrors, 2)) * ...
        (1 / maxAllowableError) * groundReactionMomentSlopeErrors(3, :)];
end
if (params.tasks{task}.costTerms.springConstantErrorFromMean.isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.springConstantErrorFromMean ...
        .maxAllowableError;
    cost = [cost sqrt(1 / length(valuesStruct.springConstants)) * ...
        (1 / maxAllowableError) * ...
        calcSpringConstantsErrorFromMean(valuesStruct.springConstants)];
end
% Spring constant error from neighbors is raised to a higher power to more
% heavily penalize discontinuity in stiffness and reduce unneeded cost
% within the allowable error range
if (params.tasks{task}.costTerms.springConstantErrorFromNeighbors ...
        .isEnabled)
    maxAllowableError = ...
        params.tasks{task}.costTerms.springConstantErrorFromNeighbors ...
        .maxAllowableError;
    cost = [cost sqrt(1 / (size(modeledValues.gaussianWeights, 1) * ...
        size(modeledValues.gaussianWeights, 2))) * ...
        ((1 / maxAllowableError) * ...
        calcSpringConstantsErrorFromNeighbors( ...
        valuesStruct.springConstants, modeledValues.gaussianWeights)).^ 4];
end
end
