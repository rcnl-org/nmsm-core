% This function is part of the NMSM Pipeline, see file for full license.
%
% This function calculates the cost associated to joint moment matching   %
% while penalizing muscle parameter differences and violations.           %
%
% inputs
%
% (Array of number, struct) -> (Array of number)
% returns the cost for all rounds of the Muscle Tendon optimization

% ----------------------------------------------------------------------- %
% The NMSM Pipeline is a toolkit for model personalization and treatment  %
% optimization of neuromusculoskeletal models through OpenSim. See        %
% nmsm.rice.edu and the NOTICE file for more information. The             %
% NMSM Pipeline is developed at Rice University and supported by the US   %
% National Institutes of Health (R01 EB030520).                           %
%                                                                         %
% Copyright (c) 2021 Rice University and the Authors                      %
% Author(s): Marleny Vega                                                 %
%                                                                         %
% Licensed under the Apache License, Version 2.0 (the "License");         %
% you may not use this file except in compliance with the License.        %
% You may obtain a copy of the License at                                 %
% http://www.apache.org/licenses/LICENSE-2.0.                             %
%                                                                         %
% Unless required by applicable law or agreed to in writing, software     %
% distributed under the License is distributed on an "AS IS" BASIS,       %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or         %
% implied. See the License for the specific language governing            %
% permissions and limitations under the License.                          %
% ----------------------------------------------------------------------- %

function [outputCost] = computeMuscleTendonCostFunction(secondaryValues, ...
    primaryValues, IsIncluded, params)

% Update these functions to call findCorrectValues
[~,EMG] = calcMuscleExcitations(params);
[NeuralActivations] = calcNeuralActivations(params,EMG);
[muscleActivations] = calcMuscleActivations(params,NeuralActivations);

% Update these functions to call findCorrectValues
[passiveForce, muscleForce, muscleMoments, modelMoments] = ...
    calcMuscleMomentsAndForces(momentArms, hillTypeParams, ...
    muscleActivations);
[lMtilda, vMtilda] = ...
    calcNormalizedMusceFiberLengthsAndVelocities(hillTypeParams);

% valuesStruct needs to be created to contain (primaryValues, ...
% secondaryValues, IsIncluded)
costStructure = calcAllTrackingCosts(valuesStruct, params, ...
    modelMoments, lMtilda);
costStructure = calcAllDeviationPenaltyCosts(valuesStruct, params, ...
    passiveForce);
costStructure = calcLmTildaCurveChangesCost(lMtilda, lMtildaExprimental, ...
    lmtildaPairs, params);
costStructure = calcPairedMusclePenalties(valuesStruct, ActivationPairs, ...
    params);

% Combine all costs into single vector
outputCost = [ ...
    % Minimize joint moment tracking errors
    sqrt(params.costWeight(1)).* cost.momentMatching(:); ...  
    % Penalize difference of tact from set point
    sqrt(params.costWeight(2)).* cost.activationTimePenalty(:); ...
    % Penalize difference of Anonlin from set point
    sqrt(params.costWeight(3)).* cost.activationNonlinearityPenalty(:); ...
    % Penalize difference of lmo values from pre-calibrated values
    sqrt(params.costWeight(4)).* cost.lMoPenalty(:);... 
    % Penalize difference of lts values from pre-calibrated values
    sqrt(params.costWeight(5)).* cost.lTsPenalty(:);...    
    % Penalize difference of EMGScale from set point
    sqrt(params.costWeight(6)).* cost.emgScalePenalty(:);... 
    % Penalize change of lMtilda from pre-calibrated values
    sqrt(params.costWeight(7)).* cost.lMtildaPenalty(:);...    
    % Penalize violation of lMtilda similarity between paired muscles
    sqrt(params.costWeight(8)).* cost.lmtildaPairedSimilarity(:);...
    % Penalize violation of EMGScales similarity between paired muscles
    sqrt(params.costWeight(9)).* cost.emgScalePairedSimilarity(:);...  
    % Penalize violation of tdelay similarity between paired muscles
    sqrt(params.costWeight(10)).*cost.tdelayPairedSimilarity(:);... 
    % Minimize passive force
    sqrt(params.costWeight(11)).*cost.minPassiveForce(:);...            
    ];...                  

Cost(isnan(Cost))=0;
end
function output = compress3dMatrixTo2d(input)

    output = reshape(input,size(input,1)*size(input,2),size(input,3));
end
function output = calcMeanDifference1D(input)

    output = input - mean(input,1);
end
function output = calcMeanDifference2D(input)

    output = input - mean(input,2);
end
function [lmtildaMeanSimilarityError, lmtildaShapeSimilarityError] = ...
    calcChangesInNormalizedMuscleFiberLengthCurves(lMtilda, ...
    lMtildaExprimental, lmtildaPairs)

% Penalize violation of lMtilda similarity between paired muscles
Ind = 1;
for i = 1:length(lmtildaPairs)
    % original distance of mean value of each lMtilda from the mean of all 
    % lMtilda curves
    distMeanlmtildaOrigSimilarity = calcMeanDifference2D(mean( ...
        compress3dMatrixTo2d(lMtildaExprimental(:, :, lmtildaPairs{i})),1));
    % Distance of mean value of each lMtilda from the mean of all original
    % lMtilda curves
    distMeanlmtildaSimilarity = mean(compress3dMatrixTo2d(lMtilda(:, :, ...
        lmtildaPairs{i})), 1) - mean(mean(compress3dMatrixTo2d( ...
        lMtildaExprimental(:, :, lmtildaPairs{i}))));
    % Penalize the change between new and original distances
    lmtildaMeanSimilarityError(Ind:Ind + size(lmtildaPairs{i}, 2) - 1) = ...
        calcMeanDifference2D(distMeanlmtildaSimilarity - ...
        distMeanlmtildaOrigSimilarity);
    lmtildaShape = calcMeanDifference1D(compress3dMatrixTo2d(lMtilda(:, ...
        :, lmtildaPairs{i})));
    lmtildaShapeSimilarityError(:, Ind:Ind + size(lmtildaPairs{i}, 2) - 1) ...
        = calcMeanDifference2D(lmtildaShape);
    Ind = Ind + size(lmtildaPairs{i}, 2);
end
end
function DVs_EMGScale = calcDifferencesInEMGPairs( ...
    EMGScale, ActivationPairs)

Ind = 1;
for i = 1:length(ActivationPairs)
    DVs_EMGScale(:, Ind:Ind + size(ActivationPairs{i}, 2) - 1) = ...
        calcMeanDifference2D(EMGScale(ActivationPairs{i}));
    Ind = Ind + size(ActivationPairs{i}, 2);
end
end
function cost = calcAllTrackingCosts(valuesStruct, params, ...
    modelMoments, lMtilda)
% Minimize joint moment tracking errors
cost.momentMatching = calcTrackingCostTerm(modelMoments, ...
    params.experimentalMoments, params.errorCenters(1), ...
    params.maxAllowableErrors(1));
% Penalize difference of lMo values from pre-calibrated values
cost.lMoPenalty = calcTrackingCostTerm(findCorrectValues(5, ...
    valuesStruct), params.lMoNominal, params.errorCenters(4), ...
    params.maxAllowableErrors(4));
% Penalize difference of lTs values from pre-calibrated values
cost.lTsPenalty = calcTrackingCostTerm(findCorrectValues(6, ...
    valuesStruct), params.lTsNominal, params.errorCenters(5), ...
    params.maxAllowableErrors(5));
% Penalize change of lMtilda from pre-calibrated values
costlMtildaMeanPenalty = calcTrackingCostTerm(permute(mean(lMtilda,2), ...
    [1 3 2]), permute(mean(params.lMtildaExprimental,2),[1 3 2]), ...
    params.errorCenters(7), params.maxAllowableErrors(7));
costlMtildaShapePenalty = calcTrackingCostTerm( ...
    calcMeanDifference1D(compress3dMatrixTo2d(lMtilda)), ...
    calcMeanDifference1D(compress3dMatrixTo2d(params.lMtildaExprimental)), ...
    params.errorCenters(7), params.maxAllowableErrors(7));
cost.lMtildaPenalty = [costlMtildaMeanPenalty; costlMtildaShapePenalty];
end
function cost = calcAllDeviationPenaltyCosts(valuesStruct, params, passiveF)

% Penalize difference of tact from set point
cost.activationTimePenalty = calcPenalizeDifferencesCostTerm( ...
    findCorrectValues(2, valuesStruct), params.errorCenters(2), ...
    params.maxAllowableErrors(2));
% Penalize difference of Anonlin from set point
cost.activationNonlinearityPenalty = calcPenalizeDifferencesCostTerm( ...
    findCorrectValues(3, valuesStruct), params.errorCenters(3), ...
    params.maxAllowableErrors(3));
% Penalize difference of EMGScale from set point
cost.emgScalePenalty = calcPenalizeDifferencesCostTerm( ...
    findCorrectValues(4, valuesStruct), params.errorCenters(6), ...
    params.maxAllowableErrors(6));
% Minimize passive force
cost.minPassiveForce = calcPenalizeDifferencesCostTerm(passiveF, ...
    params.errorCenters(11), params.maxAllowableErrors(11));
end
function cost = calcLmTildaCurveChangesCost(lMtilda, lMtildaExprimental, ...
    lmtildaPairs, params)

% Penalize violation of lMtilda similarity between paired muscles
[lmtildaMeanSimilarityError, lmtildaShapeSimilarityError] = ...
    calcChangesInNormalizedMuscleFiberLengthCurves(lMtilda, ...
    lMtildaExprimental, lmtildaPairs);
lmtildaMeanSimilarityPenalty = calcPenalizeDifferencesCostTerm( ...
    lmtildaMeanSimilarityError, params.errorCenters(8), ...
    params.maxAllowableErrors(8));
lmtildaShapeSimilarityPenalty = calcPenalizeDifferencesCostTerm( ...
    lmtildaShapeSimilarityError, params.errorCenters(8), ...
    params.maxAllowableErrors(8));
cost.lmtildaPairedSimilarity = [lmtildaMeanSimilarityPenalty; ...
    lmtildaShapeSimilarityPenalty];
end
function cost = calcPairedMusclePenalties(valuesStruct, ActivationPairs, ...
    params)

% Penalize violation of EMGScales similarity between paired muscles
DVs_EMGScale = calcDifferencesInEMGPairs(findCorrectValues(4, ...
    valuesStruct), ActivationPairs);
cost.emgScalePairedSimilarity = calcPenalizeDifferencesCostTerm(DVs_EMGScale, ...
    params.errorCenters(9), params.maxAllowableErrors(9));
% Penalize violation of tdelay similarity between paired muscles
if size(findCorrectValues(1, valuesStruct),2)>2
    DVs_tdelay = calcDifferencesInEMGPairs(findCorrectValues(1, ...
        valuesStruct), ActivationPairs);
    cost.tdelayPairedSimilarity = calcPenalizeDifferencesCostTerm( ...
        DVs_tdelay, params.errorCenters(10), params.maxAllowableErrors(10));
else
    cost.tdelayPairedSimilarity = 0;
end
end
