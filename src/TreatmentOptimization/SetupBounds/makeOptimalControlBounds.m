% This function is part of the NMSM Pipeline, see file for full license.
%
% This functions computes the maximum and minimum values for all design
% variables. The maximum and minimum values for most design variables are
% based on the multiples value selected by the user times the range of data.
% For example, if the angle B has a range of -5 to +5, and state position
% multiple is 1, the maximum value of angle B is 15 and the minimum value
% of angle B is -15.
%
% (struct) -> (struct)
% Computes max and min design variable bounds

% ----------------------------------------------------------------------- %
% The NMSM Pipeline is a toolkit for model personalization and treatment  %
% optimization of neuromusculoskeletal models through OpenSim. See        %
% nmsm.rice.edu and the NOTICE file for more information. The             %
% NMSM Pipeline is developed at Rice University and supported by the US   %
% National Institutes of Health (R01 EB030520).                           %
%                                                                         %
% Copyright (c) 2021 Rice University and the Authors                      %
% Author(s): Marleny Vega, Claire V. Hammond                              %
%                                                                         %
% Licensed under the Apache License, Version 2.0 (the "License");         %
% you may not use this file except in compliance with the License.        %
% You may obtain a copy of the License at                                 %
% http://www.apache.org/licenses/LICENSE-2.0.                             %
%                                                                         %
% Unless required by applicable law or agreed to in writing, software     %
% distributed under the License is distributed on an "AS IS" BASIS,       %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or         %
% implied. See the License for the specific language governing            %
% permissions and limitations under the License.                          %
% ----------------------------------------------------------------------- %

function inputs = makeOptimalControlBounds(inputs)
checkBoundsLengths(inputs);
inputs = makeStateBounds(inputs);
inputs = makeControlBounds(inputs);
end

function inputs = makeStateBounds(inputs)

stateJointAngles = subsetDataByCoordinates( ...
    inputs.experimentalJointAngles, ...
    inputs.coordinateNames, ...
    inputs.statesCoordinateNames);
stateJointVelocities = subsetDataByCoordinates( ...
    inputs.experimentalJointVelocities, ...
    inputs.coordinateNames, ...
    inputs.statesCoordinateNames);

minRange = max(inputs.jointPositionsMultiple .* range(stateJointAngles), ...
    inputs.jointPositionsMinRange);
maxStatePositions = max(stateJointAngles) + minRange;
minStatePositions = min(stateJointAngles) - minRange;
minRange = max(inputs.jointVelocitiesMultiple .* ...
    range(stateJointVelocities), inputs.jointVelocitiesMinRange);
maxStateVelocities = max(stateJointVelocities) + minRange;
minStateVelocities = min(stateJointVelocities) - minRange;

inputs.maxState = [ ...
    maxStatePositions, ...
    maxStateVelocities, ...
    ];
inputs.minState = [ ...
    minStatePositions, ...
    minStateVelocities, ...
    ];

if inputs.useJerk
    stateJointAccelerations = subsetDataByCoordinates( ...
        inputs.experimentalJointAccelerations, ...
        inputs.coordinateNames, ...
        inputs.statesCoordinateNames);
    minRange = max(inputs.jointJerksMultiple .* ...
        range(stateJointAccelerations), inputs.jointAccelerationsMinRange);
    maxStateAccelerations = max(stateJointAccelerations) + minRange;
    minStateAccelerations = min(stateJointAccelerations) - minRange;
    inputs.maxState = [inputs.maxState, maxStateAccelerations];
    inputs.minState = [inputs.minState, minStateAccelerations];
end

if inputs.useControlDerivatives
    [maxControl, minControl] = makeNonDerivativeControlBounds(inputs);
    inputs.maxState = [inputs.maxState, maxControl];
    inputs.minState = [inputs.minState, minControl];
end
end

function inputs = makeControlBounds(inputs)
if inputs.useJerk
    stateJointJerks = subsetDataByCoordinates( ...
        inputs.experimentalJointJerks, ...
        inputs.coordinateNames, ...
        inputs.statesCoordinateNames);
    minRange = max(inputs.jointJerksMultiple .* ...
        range(stateJointJerks), inputs.jointJerksMinRange);
    inputs.maxControl = max(stateJointJerks) + minRange;
    inputs.minControl = min(stateJointJerks) - minRange;
else
    stateJointAccelerations = subsetDataByCoordinates( ...
        inputs.experimentalJointAccelerations, ...
        inputs.coordinateNames, ...
        inputs.statesCoordinateNames);
    minRange = max(inputs.jointAccelerationsMultiple .* ...
        range(stateJointAccelerations), inputs.jointAccelerationsMinRange);
    inputs.maxControl = max(stateJointAccelerations) + minRange;
    inputs.minControl = min(stateJointAccelerations) - minRange;
end

if inputs.useControlDerivatives
    [maxControl, minControl] = makeDerivativeControlBounds(inputs);
    inputs.maxControl = [inputs.maxControl, maxControl];
    inputs.minControl = [inputs.minControl, minControl];
else
    [maxControl, minControl] = makeNonDerivativeControlBounds(inputs);
    inputs.maxControl = [inputs.maxControl, maxControl];
    inputs.minControl = [inputs.minControl, minControl];
end

if inputs.controllerTypes(2) && inputs.optimizeSynergyVectors
    numParameters = 0;
    for i = 1 : length(inputs.synergyGroups)
        numParameters = numParameters + ...
            inputs.synergyGroups{i}.numSynergies * ...
            length(inputs.synergyGroups{i}.muscleNames);
    end
    inputs.maxParameter = ones(1, numParameters) * ...
        inputs.synergyNormalizationValue;
    inputs.minParameter = zeros(1, numParameters);
end
if ~isfield(inputs, "maxParameter")
    inputs.maxParameter = [];
    inputs.minParameter = [];
end
for i = 1:length(inputs.userDefinedVariables)
    inputs.maxParameter = [inputs.maxParameter ...
        inputs.userDefinedVariables{i}.upper_bounds];
    inputs.minParameter = [inputs.minParameter ...
        inputs.userDefinedVariables{i}.lower_bounds];
end
end

function [maxBound, minBound] = makeNonDerivativeControlBounds(inputs)
maxBound = [];
minBound = [];
if inputs.controllerTypes(4)
    maxBound = [maxBound inputs.userControlMaxValues];
    minBound = [minBound inputs.userControlMinValues];
end
if inputs.controllerTypes(3)
    maxBound = [maxBound ones(1, ...
        inputs.numIndividualMuscles)];
    minBound = [minBound zeros(1, ...
        inputs.numIndividualMuscles)];
end
if inputs.controllerTypes(2)
    maxControlSynergyActivations = inputs.maxControlSynergyActivations * ...
        ones(1, inputs.numSynergies);
    maxBound = [maxBound maxControlSynergyActivations];
    minBound = [minBound zeros(1, inputs.numSynergies)];
end
if isfield(inputs, "torqueControllerCoordinateNames")
    maxTorqueControls = [];
    minTorqueControls = [];
    for i = 1:length(inputs.torqueControllerCoordinateNames)
        indx = find(strcmp(convertCharsToStrings( ...
            inputs.inverseDynamicsMomentLabels), ...
            strcat(inputs.torqueControllerCoordinateNames(i), '_moment')));
        if isempty(indx)
            indx = find(strcmp(convertCharsToStrings( ...
                inputs.inverseDynamicsMomentLabels), ...
                strcat(inputs.torqueControllerCoordinateNames(i), '_force')));
        end
        minRange = max(inputs.maxTorqueControlsMultiple .* ...
            range(inputs.experimentalJointMoments(:, indx)), ...
            inputs.maxTorqueControlsMinRange);
        maxTorqueControls(i) = max(inputs.experimentalJointMoments(:, ...
            indx)) + minRange;
        minTorqueControls(i) = min(inputs.experimentalJointMoments(:, ...
            indx)) - minRange;
    end
    maxBound = [maxBound maxTorqueControls];
    minBound = [minBound minTorqueControls];
end
end

function [maxBound, minBound] = makeDerivativeControlBounds(inputs)
maxBound = [];
minBound = [];
if inputs.controllerTypes(4)
    derivatives = inputs.initialUserDefinedControlDerivatives;
    minRange = max(inputs.userControlDerivativesMultiple .* ...
        range(derivatives), inputs.userControlDerivativesMinRange);
    maxValues = max(derivatives) + minRange;
    minValues = min(derivatives) - minRange;
    maxBound = [maxBound, maxValues];
    minBound = [minBound, minValues];
end
if inputs.controllerTypes(3)
    derivatives = inputs.initialMuscleControlDerivatives;
    minRange = max(inputs.muscleControlDerivativesMultiple .* ...
        range(derivatives), inputs.muscleControlDerivativesMinRange);
    maxValues = max(derivatives) + minRange;
    minValues = min(derivatives) - minRange;
    maxBound = [maxBound, maxValues];
    minBound = [minBound, minValues];
end
if inputs.controllerTypes(2)
    derivatives = inputs.initialSynergyControlDerivatives;
    minRange = max(inputs.synergyControlDerivativesMultiple .* ...
        range(derivatives), inputs.synergyControlDerivativesMinRange);
    maxValues = max(derivatives) + minRange;
    minValues = min(derivatives) - minRange;
    maxBound = [maxBound, maxValues];
    minBound = [minBound, minValues];
end
if isfield(inputs, "torqueControllerCoordinateNames")
    maxTorqueControls = [];
    minTorqueControls = [];
    torqueControlDerivatives = evaluateGcvSplines( ...
        inputs.splineJointMoments, inputs.inverseDynamicsMomentLabels, ...
        inputs.experimentalTime, 1);
    for i = 1:length(inputs.torqueControllerCoordinateNames)
        indx = find(strcmp(convertCharsToStrings( ...
            inputs.inverseDynamicsMomentLabels), ...
            strcat(inputs.torqueControllerCoordinateNames(i), '_moment')));
        if isempty(indx)
            indx = find(strcmp(convertCharsToStrings( ...
                inputs.inverseDynamicsMomentLabels), ...
                strcat(inputs.torqueControllerCoordinateNames(i), '_force')));
        end
        minRange = max(inputs.maxTorqueControlsMultiple .* ...
            range(inputs.experimentalJointMoments(:, indx)), ...
            inputs.maxTorqueControlsMinRange);
        maxTorqueControls(i) = max(torqueControlDerivatives(:, ...
            indx)) + minRange;
        minTorqueControls(i) = min(torqueControlDerivatives(:, ...
            indx)) - minRange;
    end
    maxBound = [maxBound maxTorqueControls];
    minBound = [minBound minTorqueControls];
end
end

function checkBoundsLengths(inputs)
numCoordinates = length(inputs.statesCoordinateNames);
boundFieldNames = ["jointPositionsMultiple", ...
    "jointVelocitiesMultiple", "jointAccelerationsMultiple", ...
    "jointJerksMultiple", "jointPositionsMinRange", ...
    "jointVelocitiesMinRange", "jointAccelerationsMinRange", ...
    "jointJerksMinRange"];
xmlFieldNames = ["joint_position_range_scale_factor", ...
    "joint_velocity_range_scale_factor", ...
    "joint_acceleration_range_scale_factor", ...
    "joint_jerk_range_scale_factor", ...
    "joint_position_minimum_range", ...
    "joint_velocity_minimum_range", ...
    "joint_acceleration_minimum_range", ...
    "joint_jerk_minimum_range"];
for i = 1 : length(boundFieldNames)
    if mod(i, 4) ~= 0 || inputs.useJerk
        assert(length(inputs.(boundFieldNames(i))) == 1 || ...
            length(inputs.(boundFieldNames(i))) == numCoordinates, ...
            "<" + xmlFieldNames(i) + "> must have a single value or " + ...
            "one corresponding value for each coordinate in the " + ...
            "<states_coordinate_list>.")
    end
end

if inputs.controllerTypes(1)
    numControls = length(inputs.torqueControllerCoordinateNames);
    boundFieldNames = ["maxTorqueControlsMultiple", ...
        "maxTorqueControlsMinRange"];
    xmlFieldNames = ["torque_controls_range_scale_factor", ...
        "torque_controls_minimum_range"];
    for i = 1 : length(boundFieldNames)
        assert(length(inputs.(boundFieldNames(i))) == 1 || ...
            length(inputs.(boundFieldNames(i))) == numControls, ...
            "<" + xmlFieldNames(i) + "> must have a single value or " + ...
            "one corresponding value for each coordinate in the " + ...
            "<RCNLTorqueController>'s <coordinate_list>.")
    end
end

if inputs.useControlDerivatives
    numControls = ...
        repelem([length(inputs.torqueControllerCoordinateNames), ...
        inputs.numSynergies, inputs.numIndividualMuscles, ...
        inputs.numUserDefinedControls], 1, 2);
    includedBounds = repelem(inputs.controllerTypes, 1, 2);
    boundFieldNames = ["torqueControlDerivativesMultiple", ...
        "torqueControlDerivativesMinRange", ...
        "synergyControlDerivativesMultiple", ...
        "synergyControlDerivativesMinRange", ...
        "muscleControlDerivativesMultiple", ...
        "muscleControlDerivativesMinRange", ...
        "userControlDerivativesMultiple", ...
        "userControlDerivativesMinRange"];
    xmlFieldNames = ["torque_control_derivatives_range_scale_factor", ...
        "torque_control_derivatives_minimum_range", ...
        "synergy_control_derivatives_range_scale_factor", ...
        "synergy_control_derivatives_minimum_range", ...
        "muscle_control_derivatives_range_scale_factor", ...
        "muscle_control_derivatives_minimum_range", ...
        "user_defined_control_derivatives_range_scale_factor", ...
        "user_defined_control_derivatives_minimum_range"];
    controllerNames = repelem(["RCNLTorqueController", ...
        "RCNLSynergyController", "RCNLMuscleController", ...
        "RCNLUserDefinedController"], 1, 2);
    for i = 1 : length(boundFieldNames)
        if includedBounds(i)
            assert(length(inputs.(boundFieldNames(i))) == 1 || ...
                length(inputs.(boundFieldNames(i))) == numControls(i), ...
                "<" + xmlFieldNames(i) + "> must have a single " + ...
                "value or one corresponding value for each control " + ...
                "in the <" + controllerNames(i) + ">.")
        end
    end
end
end
