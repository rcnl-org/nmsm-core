% This function is part of the NMSM Pipeline, see file for full license.
%
% This function calculates the metabolic power (W) based on Bhagarva
% et al., (2004), Arones et al., (2020) and OpenSim
% Bhargava2004SmoothedMuscleMetabolics.cpp 
%
% (double, Array of double, Array of double, Array of double, 
% Array of double, Array of double, Array of double, Array of double) 
% -> (Array of double)
% returns the metabolic power

% ----------------------------------------------------------------------- %
% The NMSM Pipeline is a toolkit for model personalization and treatment  %
% optimization of neuromusculoskeletal models through OpenSim. See        %
% nmsm.rice.edu and the NOTICE file for more information. The             %
% NMSM Pipeline is developed at Rice University and supported by the US   %
% National Institutes of Health (R01 EB030520).                           %
%                                                                         %
% Copyright (c) 2021 Rice University and the Authors                      %
% Author(s): Claire V. Hammond, Spencer Williams, Geng Li, Marleny Vega   %
%                                                                         %
% Licensed under the Apache License, Version 2.0 (the "License");         %
% you may not use this file except in compliance with the License.        %
% You may obtain a copy of the License at                                 %
% http://www.apache.org/licenses/LICENSE-2.0.                             %
%                                                                         %
% Unless required by applicable law or agreed to in writing, software     %
% distributed under the License is distributed on an "AS IS" BASIS,       %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or         %
% implied. See the License for the specific language governing            %
% permissions and limitations under the License.                          %
% ----------------------------------------------------------------------- %
function metabolicPower = calcBhargavaMetabolicCost(mass, ...
    allMuscleActivations, normalizedMuscleFiberLengths, ...
    normalizedMuscleFiberVelocities, maxIsometricForce, optimalFiberLength,...
    vMaxFactor,pennationAngle)

% muscle constants
muscleSpecificStress = 610e3; % N/square meters
muscleDensity = 1059.7; % kg/cubic meters
% smoothing constants, used in a tanh function to ensure smooth function
% OpenSim Bhargava2004SmoothedMuscleMetabolics.cpp
% https://github.com/opensim-org/opensim-core/blob/main/OpenSim/Simulation/Model/Bhargava2004SmoothedMuscleMetabolics.cpp
b1 = 10; % smooth the power by returning 0 (negative power) or 1 (non-negative power)
b2 = 10; % smooth the heat rate by returning 0 (1-heat rate < 0)  or 1 (1-heat rate > 0)
b3 = 10; % smooth the velocities of the muscle fibers by returning 0 (shortening) or 1 (lengthening or eccentric contraction)
% basal rate constants 
% basalRate = basalCoefficient * modelMass ^ basalExponent
% OpenSim Bhargava2004SmoothedMuscleMetabolics.cpp
basalCoefficient = 1.2;
basalExponent = 1.0;

% mass fraction of fast twitch fibers (fiberTypeRatio), 
% mass fraction of slow twitch fibers = 1 - fiberTypeRatio 
fiberTypeRatio = 0.5;

% preallocate metabolic power for muscles vector
metabolicPowerMuscles = zeros(size(allMuscleActivations, 1), 1);

% calculate metabolic power of individual muscle
for i = 1:size(allMuscleActivations, 2) 
    activations = allMuscleActivations(:, i);
    % actvations of fast twitch muscle fibers 
    fastActivation = fiberTypeRatio * (1 - cos(pi / 2 * activations));
    % actvations of slow twitch muscle fibers
    slowActivation = (1 - fiberTypeRatio) * (sin(pi / 2 * activations));
    % forces generated by the contractile element of the individual muscle
    contractileElementForce = (maxIsometricForce(i) .* activations .* ...
        activeForceLengthCurve(normalizedMuscleFiberLengths(:, i)) .* ...
        forceVelocityCurve(normalizedMuscleFiberVelocities(:, i)));
    % individual muscle mass
    muscleMass = muscleDensity * maxIsometricForce(i) / muscleSpecificStress * optimalFiberLength(i);
    % activation heat rate
    activationHeatRate = calcActivationHeatRate(muscleMass, fastActivation, ...
        slowActivation);
    % maintenance heat rate
    maintenanceHeatRate = calcMaintenanceHeatRate(muscleMass, fastActivation, ...
        slowActivation, normalizedMuscleFiberLengths(:, i));
    % shortening heat rate
    shorteningHeatRate = calcShorteningHeatRate(...
        normalizedMuscleFiberLengths(:, i), normalizedMuscleFiberVelocities(:, i), ...
        contractileElementForce, optimalFiberLength(i), maxIsometricForce(i), ...
        pennationAngle(i), vMaxFactor, b3);
    % mechanical work rate
    workRate = calcWorkRate(contractileElementForce, ...
        optimalFiberLength(i), normalizedMuscleFiberVelocities(:, i), ...
        pennationAngle(i), vMaxFactor, b3); 
    % total power (= activationHeatRate + maintenanceHeatRate + 
    % shorteningHeatRate + workRate) should be non-negative. 
    % Increase the shorteningHeatCost until the total power rate 
    % is non-negative 
    totalPower = activationHeatRate + maintenanceHeatRate + ...
        shorteningHeatRate + workRate; 
    % totalPowerRate < 0, totalPowerRateNegativeCoef = 1
    totalPowerRateNegativeCoef = 0.5 + (0.5 * tanh(b1 * (-totalPower)));
    % correct the shorteningHeatRate to drive negative totalPower to 0 
    shorteningHeatRateCorrected = shorteningHeatRate - totalPower .* totalPowerRateNegativeCoef; 

    % total heat rate (activationHeatRate + maintenanceHeatRate +
    % shorteningHeatRate) per mass
    % for a given muscle cannot fall below 1.0 W/kg per Umberger 2003
    totalHeatRate = (activationHeatRate + maintenanceHeatRate + shorteningHeatRateCorrected)/muscleMass;
    % totalHeatRate < 1 W/kg, totalHeatRateBelowOneCoef = 1
    % totalHeatRate > 1 W/kg, totalHeatRateBelowOneCoef = 0
    totalHeatRateBelowOneCoef = (0.5 + 0.5*tanh(b2*(1 - totalHeatRate))); 
    % totalHeatRate = totalHeatRate (when totalHeatRate > 1) 
    % or 1 W/kg (when totalHeatRate < 1)                
    totalHeatRate = totalHeatRate + (-totalHeatRate + ones(size(totalHeatRate)))...
        .* totalHeatRateBelowOneCoef;
    totalHeatRate = totalHeatRate*muscleMass; % express total heat rate back in W

    % total energy rate of individual muscle added to total
    metabolicPowerMuscles = metabolicPowerMuscles + totalHeatRate + workRate;    
end

% basal rate
basalRate = calcBasalRate(mass, basalCoefficient, basalExponent);

% overall metabolic power
metabolicPower = metabolicPowerMuscles + basalRate;
end

function activationHeatRate = calcActivationHeatRate(mass, ...
    fastActivation, slowActivation)
% This function calculates the activationHeatRate of an individual muscle 
% using muscle mass, and activations of both fast and slow twitch fibers

% assume decay function phi = 1
phi  = 1;

fastActivationConstant = 133; % (W/kg) activation heat rate constants for fast twitch fibers 
slowActivationConstant = 40; % (W/kg) activation heat rate constants for fast twitch fibers

activationHeatRate = phi * mass .* (fastActivation .* fastActivationConstant ...
    + slowActivation .* slowActivationConstant);
end

function maintenanceHeatRate = calcMaintenanceHeatRate(mass, ...
    fastActivation, slowActivation, normalizedMuscleFiberLengths)
% This function calculates the maintenanceHeatRate of an individual muscle 
% using muscle mass, activations of both fast and slow twitch fibers, and
% normalized muscle fiber lengths

fastMaintenanceConstant = 111; % (W/kg) maintenance heat rate constants for fast twitch fibers
slowMaintenanceConstant = 74; % (W/kg) maintenance heat rate constants for fast twitch fibers

% length factor returns values between 0 and 1 depending on the ranges of
% normalized muscle fiber length
lengthFactor = zeros(length(normalizedMuscleFiberLengths), 1);
for i = 1:length(normalizedMuscleFiberLengths)
    if normalizedMuscleFiberLengths(i) <= 0.5
        lengthFactor(i) = 0.5;
    elseif normalizedMuscleFiberLengths(i) <= 1
        lengthFactor(i) = normalizedMuscleFiberLengths(i);
    elseif normalizedMuscleFiberLengths(i) <= 1.5
        lengthFactor(i) = -2 * normalizedMuscleFiberLengths(i) + 3;
    end
end

maintenanceHeatRate = mass .* lengthFactor .* ...
    ((fastMaintenanceConstant * fastActivation) + ...
    (slowMaintenanceConstant * slowActivation));
end

function shorteningHeatRate = calcShorteningHeatRate(...
    normalizedMuscleFiberLengths, normalizedMuscleFiberVelocities, ...
    contractileElementForce, optimalFiberLength, maxIsometricForce,...
    pennationAngle, vMaxFactor, b3)
% This function calculates the maintenanceHeatRate using 
% normalized muscle fiber lengths and velocities, contractile element forces,
% max isometric forces, optimal fiber lengths, pennation angles, 
% max fiber shortening velocities and velocity smoothing constant

% using contractileElementForce to calculate the isometricForce of the
% muscle (at velocities = 0)
isometricForce = contractileElementForce .*...
    forceVelocityCurve(zeros(size(normalizedMuscleFiberVelocities))) ./...
    forceVelocityCurve(normalizedMuscleFiberVelocities);
% total forces generated by muscle fibers, active + passive 
muscleFiberForceTotal = contractileElementForce + maxIsometricForce .* ...
    passiveForceLengthCurve(normalizedMuscleFiberLengths);
% muscle fiber velocities
muscleFiberVelocities = normalizedMuscleFiberVelocities * ...
    (vMaxFactor*optimalFiberLength) *...
    cos(pennationAngle);

% muscleFiberVelocitiesPositiveCoef = 0 (muscleFiberVelocities<0) or 1 (muscleFiberVelocities<0) 
muscleFiberVelocitiesPositiveCoef = 0.5 + 0.5*tanh(b3*(muscleFiberVelocities));

% the if else statements used to calculate forceProportionality depending on
% positive or negative velocities is replaced by a tanh smoothing function

% when muscleFiberVelocities <= 0,
forceProportionality = 0.16 * isometricForce + 0.18 * muscleFiberForceTotal;

% when muscleFiberVelocities > 0,
forceProportionality = forceProportionality + (-forceProportionality +...
    0.157 * muscleFiberForceTotal) .* muscleFiberVelocitiesPositiveCoef;

shorteningHeatRate = -forceProportionality .* ...
    muscleFiberVelocities;

end

function workRate = calcWorkRate(contractileElementForce, ...
    optimalFiberLength, normalizedMuscleFiberVelocities, pennationAngle, ...
    vMaxFactor, b3) 
% This function calculates the workRate using contractile element forces,
% optimal fiber lengths, normalized muscle fiber velocities, 
% pennation angles, max fiber shortening velocities and 
% velocity smoothing constant

% muscle fiber velocities
muscleFiberVelocities = normalizedMuscleFiberVelocities * ...
    (vMaxFactor*optimalFiberLength) *...
    cos(pennationAngle);

% using tanh function of muscleFiberVelocities (0 when negative, and 1 when positive)
% to exclude negative work (negative work is associated with positive
% muscleFiberVelocities)

muscleFiberVelocitiesPositiveCoef = 0.5 + 0.5*tanh(b3*(muscleFiberVelocities));
muscleFiberVelocitiesNegativeCoef = 1 - muscleFiberVelocitiesPositiveCoef;

workRate = -contractileElementForce .* ...
    muscleFiberVelocities .*...
    muscleFiberVelocitiesNegativeCoef; 

end

function basalRate = calcBasalRate(mass, basalCoefficient, basalExponent)
% This function calculates the maintenanceHeatRate using 
% the mass of the model, coefficients and exponents,

basalRate = basalCoefficient * mass ^ basalExponent; 
end

